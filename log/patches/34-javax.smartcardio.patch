Index: src/org/kapott/hbci/manager/HBCIUtils.java
===================================================================
RCS file: /cvsroot/hibiscus/hbci4java/src/org/kapott/hbci/manager/HBCIUtils.java,v
retrieving revision 1.1
diff -u -r1.1 HBCIUtils.java
--- src/org/kapott/hbci/manager/HBCIUtils.java	4 May 2011 22:37:46 -0000	1.1
+++ src/org/kapott/hbci/manager/HBCIUtils.java	24 Nov 2011 21:58:27 -0000
@@ -1,5 +1,5 @@
 
-/*  $Id: 34-javax.smartcardio.patch,v 1.1 2011/11/24 21:59:37 willuhn Exp $
+/*  $Id: 34-javax.smartcardio.patch,v 1.1 2011/11/24 21:59:37 willuhn Exp $
 
     This file is part of HBCI4Java
     Copyright (C) 2001-2008  Stefan Palme
@@ -146,6 +146,10 @@
           Da in den meisten Fällen aber nur der erste Datensatzu tatsächlich belegt
           ist, wird dieser Parameter meist den Wert "1" haben (ist auch default,
           falls dieser Parameter gar nicht gesetzt ist).</p></li>
+      <li><code>client.passport.DDV.pcsc.name</code> (für DDV-Passports bei Verwendung von HBCIPassportDDVPCSC)
+          <p>Wenn statt dem DDV-Passport der DDVPCSC-Passport (basierend auf javax.smartcardio)
+          verwendet wird, kann hier der Name des Kartenlesers angegeben werden. Andernfalls
+          wird der erste gefundene verwendet.</p></li>
       <li><code>client.passport.RDHNew.filename</code> (für RDHNew-Passports)
           <p>Dieser Parameter legt den 
           Dateinamen der Schlüsseldatei fest. Diese Datei sollte am 
Index: src/org/kapott/hbci/passport/HBCIPassportDDVPCSC.java
===================================================================
RCS file: src/org/kapott/hbci/passport/HBCIPassportDDVPCSC.java
diff -N src/org/kapott/hbci/passport/HBCIPassportDDVPCSC.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/org/kapott/hbci/passport/HBCIPassportDDVPCSC.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,402 @@
+
+/*  $Id: 34-javax.smartcardio.patch,v 1.1 2011/11/24 21:59:37 willuhn Exp $
+
+    This file is part of HBCI4Java
+    Copyright (C) 2001-2008  Stefan Palme
+
+    HBCI4Java is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    HBCI4Java is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+package org.kapott.hbci.passport;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.ObjectInputStream;
+import java.io.StreamCorruptedException;
+import java.util.List;
+import java.util.Properties;
+
+import javax.crypto.Cipher;
+import javax.crypto.CipherInputStream;
+import javax.crypto.spec.PBEParameterSpec;
+import javax.smartcardio.Card;
+import javax.smartcardio.CardTerminal;
+import javax.smartcardio.CardTerminals;
+import javax.smartcardio.TerminalFactory;
+
+import org.kapott.hbci.callback.HBCICallback;
+import org.kapott.hbci.datatypes.SyntaxCtr;
+import org.kapott.hbci.exceptions.HBCI_Exception;
+import org.kapott.hbci.exceptions.InvalidPassphraseException;
+import org.kapott.hbci.manager.HBCIKey;
+import org.kapott.hbci.manager.HBCIUtils;
+import org.kapott.hbci.manager.HBCIUtilsInternal;
+import org.kapott.hbci.smartcardio.DDVBankData;
+import org.kapott.hbci.smartcardio.DDVCardService;
+import org.kapott.hbci.smartcardio.DDVKeyData;
+
+/**
+ * Implementierung eines DDV-Passports, welcher intern die neue Chipkarten-API
+ * "javax.smartcardio" von Java 6 verwendet. Die Implementierung basiert auf
+ * dem OCF-Code von HBCI4Java 2.5.8.
+ */
+public class HBCIPassportDDVPCSC extends HBCIPassportDDV
+{
+    private Card           smartCard;
+    private DDVCardService cardService;
+    
+    /**
+     * ct.
+     * @param init
+     * @param dummy
+     */
+    public HBCIPassportDDVPCSC(Object init, int dummy)
+    {
+      super(init,dummy);
+    }
+
+    /**
+     * ct.
+     * @param init
+     */
+    public HBCIPassportDDVPCSC(Object init)
+    {
+      this(init,0);
+      
+      ObjectInputStream is = null;
+      
+      try
+      {
+        ////////////////////////////////////////////////////////////////////////
+        // set parameters for initializing card
+        this.setUseBio(Integer.parseInt(HBCIUtils.getParam(getParamHeader()+".usebio","-1")));
+        this.setUseSoftPin(Integer.parseInt(HBCIUtils.getParam(getParamHeader()+".softpin","-1")));
+        this.setSoftPin(new byte[0]);
+        this.setPINEntered(false);
+        this.setEntryIdx(Integer.parseInt(HBCIUtils.getParam(getParamHeader()+".entryidx","1")));
+        //
+        ////////////////////////////////////////////////////////////////////////
+
+        ////////////////////////////////////////////////////////////////////////
+        // init card
+        HBCIUtils.log("initializing javax.smartcardio",HBCIUtils.LOG_DEBUG);
+        HBCIUtilsInternal.getCallback().callback(this,HBCICallback.NEED_CHIPCARD,HBCIUtilsInternal.getLocMsg("CALLB_NEED_CHIPCARD"),HBCICallback.TYPE_NONE,null);
+        
+        this.initCT();
+        HBCIUtilsInternal.getCallback().callback(this,HBCICallback.HAVE_CHIPCARD,"",HBCICallback.TYPE_NONE,null);
+        //
+        ////////////////////////////////////////////////////////////////////////
+        
+        ////////////////////////////////////////////////////////////////////////
+        // init basic bank data
+        try {
+          this.setPort(new Integer(3000));
+          this.setFilterType("None");
+          this.ctReadBankData();
+            
+          if (this.askForMissingData(true,true,true,false,false,true,false))
+            this.saveBankData();
+                
+          this.ctReadKeyData();
+        }
+        catch (HBCI_Exception e1)
+        {
+          throw e1;
+        }
+        catch (Exception e)
+        {
+          throw new HBCI_Exception(HBCIUtilsInternal.getLocMsg("EXCMSG_PASSPORT_INSTDATAERR"),e);
+        }
+        //
+        ////////////////////////////////////////////////////////////////////////
+
+        ////////////////////////////////////////////////////////////////////////
+        // read passport file
+        String path = HBCIUtils.getParam(getParamHeader()+".path","./");
+        this.setFileName(HBCIUtilsInternal.withCounter(path+getCardId(),getEntryIdx()-1));
+        HBCIUtils.log("loading passport data from file "+getFileName(),HBCIUtils.LOG_DEBUG);
+        
+        File file = new File(this.getFileName());
+        if (file.exists() && file.isFile() && file.canRead())
+        {
+          int retries = Integer.parseInt(HBCIUtils.getParam("client.retries.passphrase","3"));
+
+          while (true) // loop for entering the correct passphrase
+          {
+            if (this.getPassportKey() == null)
+              this.setPassportKey(calculatePassportKey(FOR_LOAD));
+
+            PBEParameterSpec paramspec = new PBEParameterSpec(CIPHER_SALT,CIPHER_ITERATIONS);
+            Cipher cipher = Cipher.getInstance("PBEWithMD5AndDES");
+            cipher.init(Cipher.DECRYPT_MODE,getPassportKey(),paramspec);
+              
+            try
+            {
+              is = new ObjectInputStream(new CipherInputStream(new FileInputStream(file),cipher));
+            }
+            catch (StreamCorruptedException e1)
+            {
+              setPassportKey(null); // Passwort resetten
+              retries--;
+              if (retries<=0)
+                throw new InvalidPassphraseException();
+            }
+            catch (Exception e2)
+            {
+              throw new HBCI_Exception(HBCIUtilsInternal.getLocMsg("EXCMSG_PASSPORT_READERR"),e2);
+            }
+            
+            // wir habens
+            if (is != null)
+            {
+              setBPD((Properties)(is.readObject()));
+              setUPD((Properties)(is.readObject()));
+              setHBCIVersion((String)is.readObject());
+              break;
+            }
+          }
+        }
+        //
+        ////////////////////////////////////////////////////////////////////////
+      }
+      catch (Exception e)
+      {
+        // Im Fehlerfall wieder schliessen
+        try {
+          closeCT();
+        }
+        catch (Exception ex) {
+          HBCIUtils.log(ex);
+        }
+        
+        if (e instanceof HBCI_Exception)
+          throw (HBCI_Exception) e;
+        
+        throw new HBCI_Exception(HBCIUtilsInternal.getLocMsg("EXCMSG_CTERR"),e);
+      }
+      finally
+      {
+        // Close Passport-File
+        if (is != null) {
+          try {
+            is.close();
+          }
+          catch (Exception e) {
+            HBCIUtils.log(e);
+          }
+        }
+      }
+    }
+
+    /**
+     * @see org.kapott.hbci.passport.HBCIPassportDDV#initCT()
+     */
+    protected void initCT()
+    {
+      try
+      {
+        TerminalFactory terminalFactory = TerminalFactory.getDefault();
+        CardTerminals terminals = terminalFactory.terminals();
+        if (terminals == null)
+          throw new HBCI_Exception("Kein Kartenleser gefunden");
+        
+        List<CardTerminal> list = terminals.list();
+        if (list == null || list.size() == 0)
+          throw new HBCI_Exception("Kein Kartenleser gefunden");
+        
+        HBCIUtils.log("found card terminals:",HBCIUtils.LOG_INFO);
+        for (CardTerminal t:list) {
+            HBCIUtils.log("  "+t.getName(),HBCIUtils.LOG_INFO);
+        }
+
+        CardTerminal terminal = null;
+
+        // Checken, ob der User einen konkreten Kartenleser vorgegeben hat
+        String name = HBCIUtils.getParam(getParamHeader()+".pcsc.name",null);
+        if (name != null)
+        {
+          HBCIUtils.log("explicit terminal name given, trying to open terminal: " + name,HBCIUtils.LOG_DEBUG);
+          terminal = terminals.getTerminal(name);
+          if (terminal == null)
+            throw new HBCI_Exception("Kartenleser \"" + name + "\" nicht gefunden");
+        }
+        else
+        {
+          HBCIUtils.log("open first available card terminal",HBCIUtils.LOG_DEBUG);
+          terminal = list.get(0);
+        }
+        HBCIUtils.log("using card terminal " + terminal.getName(),HBCIUtils.LOG_DEBUG);
+
+        // wait for card
+        if (!terminal.waitForCardPresent(60 * 1000L))
+          throw new HBCI_Exception("Keine Chipkarte in Kartenleser " + terminal.getName() + " gefunden");
+
+        // Hier kann man gemaess
+        // http://download.oracle.com/javase/6/docs/jre/api/security/smartcardio/spec/javax/smartcardio/CardTerminal.html#connect%28java.lang.String%29
+        // auch "T=0" oder "T=1" angeben. Wir wissen allerdings noch nicht, von welchem
+        // Typ die Karte ist. Daher nehmen wir "*" fuer jedes verfuegbare. Wenn wir die
+        // Karte geoeffnet haben, kriegen wir dann auch das Protokoll raus.
+        this.smartCard = terminal.connect("*");
+        String type = this.smartCard.getProtocol();
+        HBCIUtils.log(" card type: " + type,HBCIUtils.LOG_INFO);
+        
+        // Card-Service basierend auf dem Kartentyp erzeugen
+        if (type == null || type.indexOf("=") == -1)
+          throw new HBCI_Exception("Unbekannter Kartentyp");
+
+        String id = type.substring(type.indexOf("=")+1);
+        String serviceName = "org.kapott.hbci.smartcardio.DDVCardService" + id;
+        HBCIUtils.log(" trying to load: " + serviceName,HBCIUtils.LOG_DEBUG);
+        this.cardService = (DDVCardService) Class.forName(serviceName).newInstance();
+        HBCIUtils.log(" using: " + this.cardService.getClass().getName(),HBCIUtils.LOG_INFO);
+        this.cardService.init(this.smartCard);
+        
+        // getCID
+        byte[] cid=this.cardService.getCID();
+        this.setCID(new String(cid,"ISO-8859-1"));
+        
+        // extract card id
+        StringBuffer cardId=new StringBuffer();
+        for (int i=0;i<8;i++)
+        {
+          cardId.append((char)(((cid[i+1]>>4)&0x0F) + 0x30));
+          cardId.append((char)((cid[i+1]&0x0F) + 0x30));
+        }
+        this.setCardId(cardId.toString());
+      }
+      catch (HBCI_Exception he)
+      {
+        throw he;
+      }
+      catch (Exception e)
+      {
+        throw new HBCI_Exception(e);
+      }
+    }
+    
+    /**
+     * @see org.kapott.hbci.passport.HBCIPassportDDV#ctReadBankData()
+     */
+    protected void ctReadBankData()
+    {
+      int idx = this.getEntryIdx()-1;
+      DDVBankData bankData = this.cardService.readBankData(idx);
+      
+      this.setCountry(SyntaxCtr.getName(bankData.country));
+      this.setBLZ(bankData.blz);
+      this.setHost(bankData.commaddr);
+      this.setUserId(bankData.userid);
+    }
+    
+    /**
+     * @see org.kapott.hbci.passport.HBCIPassportDDV#ctReadKeyData()
+     */
+    protected void ctReadKeyData()
+    {
+      this.setSigId(new Long(cardService.readSigId()));
+      
+      // readKeyData
+      DDVKeyData[] keyData=cardService.readKeyData();
+      
+      this.setInstSigKey(new HBCIKey(
+          getCountry(), getBLZ(), getUserId(), 
+          Integer.toString(keyData[0].num), Integer.toString(keyData[0].version), 
+          null));
+      
+      this.setInstEncKey(new HBCIKey(
+          getCountry(), getBLZ(), getUserId(), 
+          Integer.toString(keyData[1].num), Integer.toString(keyData[1].version),
+          null));
+    }
+    
+    /**
+     * @see org.kapott.hbci.passport.HBCIPassportDDV#ctEnterPIN()
+     */
+    protected void ctEnterPIN()
+    {
+      if (getUseSoftPin()==1)
+        this.cardService.verifySoftPIN(1, this.getSoftPin());
+      else
+        this.cardService.verifyHardPIN(1);
+    }
+    
+    /**
+     * @see org.kapott.hbci.passport.HBCIPassportDDV#ctSaveBankData()
+     */
+    protected void ctSaveBankData()
+    {
+      int idx = this.getEntryIdx()-1;
+      DDVBankData bankData;
+      
+      bankData=cardService.readBankData(idx);
+      bankData.country=SyntaxCtr.getCode(this.getCountry());
+      bankData.blz=this.getBLZ();
+      bankData.commaddr=this.getHost();
+      bankData.userid=this.getUserId();
+      cardService.writeBankData(idx,bankData);
+    }
+    
+    /**
+     * @see org.kapott.hbci.passport.HBCIPassportDDV#ctSaveSigId()
+     */
+    protected void ctSaveSigId()
+    {
+      cardService.writeSigId(getSigId().intValue());
+    }
+    
+    /**
+     * @see org.kapott.hbci.passport.HBCIPassportDDV#ctSign(byte[])
+     */
+    protected byte[] ctSign(byte[] data)
+    {
+      return cardService.sign(data);
+    }
+
+    /**
+     * @see org.kapott.hbci.passport.HBCIPassportDDV#ctEncrypt()
+     */
+    protected byte[][] ctEncrypt()
+    {
+      return cardService.getEncryptionKeys(Integer.parseInt(getInstEncKeyNum()));
+    }
+    
+    /**
+     * @see org.kapott.hbci.passport.HBCIPassportDDV#ctDecrypt(byte[])
+     */
+    protected byte[] ctDecrypt(byte[] cryptedKey)
+    {
+      return cardService.decrypt(Integer.parseInt(getInstEncKeyNum()),cryptedKey);
+    }
+    
+    /**
+     * @see org.kapott.hbci.passport.HBCIPassportDDV#closeCT()
+     */
+    protected void closeCT()
+    {
+      try
+      {
+        if (smartCard!=null)
+          smartCard.disconnect(false);
+      }
+      catch (HBCI_Exception e1)
+      {
+        throw e1;
+      }
+      catch (Exception e2)
+      {
+        throw new HBCI_Exception(e2);
+      }
+    }
+}
Index: src/org/kapott/hbci/smartcardio/DDVBankData.java
===================================================================
RCS file: src/org/kapott/hbci/smartcardio/DDVBankData.java
diff -N src/org/kapott/hbci/smartcardio/DDVBankData.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/org/kapott/hbci/smartcardio/DDVBankData.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,38 @@
+
+/*  $Id: 34-javax.smartcardio.patch,v 1.1 2011/11/24 21:59:37 willuhn Exp $
+
+    This file is part of HBCI4Java
+    Copyright (C) 2001-2008  Stefan Palme
+
+    HBCI4Java is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    HBCI4Java is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+package org.kapott.hbci.smartcardio;
+
+/**
+ * DDV-Bankdaten fuer den DDVPCSC-Passport, basierend auf dem OCF-Code
+ * aus HBCI4Java 2.5.8.
+ */
+public class DDVBankData
+{
+  public int    recordnum;
+  public int    commType;
+  public String shortname;
+  public String commaddr;
+  public String commaddr2;
+  public String country;
+  public String blz;
+  public String userid;
+}
Index: src/org/kapott/hbci/smartcardio/DDVCardService.java
===================================================================
RCS file: src/org/kapott/hbci/smartcardio/DDVCardService.java
diff -N src/org/kapott/hbci/smartcardio/DDVCardService.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/org/kapott/hbci/smartcardio/DDVCardService.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,241 @@
+
+/*  $Id: 34-javax.smartcardio.patch,v 1.1 2011/11/24 21:59:37 willuhn Exp $
+
+    This file is part of HBCI4Java
+    Copyright (C) 2001-2008  Stefan Palme
+
+    HBCI4Java is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    HBCI4Java is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+package org.kapott.hbci.smartcardio;
+
+import org.kapott.hbci.exceptions.HBCI_Exception;
+
+
+
+/**
+ * Abstrakter DDV-Cardservice fuer den DDVPCSC-Passport, basierend auf dem OCF-Code
+ * aus HBCI4Java 2.5.8.
+ */
+public abstract class DDVCardService extends HBCICardService
+{
+  /**
+   * Liefert die Schluesseldaten.
+   * @return die Schluesseldaten.
+   */
+  public abstract DDVKeyData[] readKeyData();
+  
+  /**
+   * Erzeugt eine Signatur.
+   * @param data_l die zu signierenden Daten.
+   * @return die Signature,
+   */
+  protected abstract byte[] calculateSignature(byte[] data_l);
+  
+  /**
+   * Liefert die CID.
+   * @return die CID.
+   */
+  public byte[] getCID() 
+  {
+    return readRecordBySFI(HBCI_DDV_EF_ID, 0);
+  }
+  
+  /**
+   * Liefert die Bank-Daten fuer den angegebenen Entry-Index.
+   * @param idx der Entry-Index.
+   * @return die Bank-Daten.
+   */
+  public DDVBankData readBankData(int idx)
+  {
+    byte[] rawData  = readRecordBySFI(HBCI_DDV_EF_BNK, idx);
+    
+    if (rawData == null)
+      return null;
+    
+    try
+    {
+      DDVBankData ret = new DDVBankData();
+      
+      ret.recordnum = idx+1;
+      ret.shortname = new String(rawData,0,20,"ISO-8859-1").trim();
+
+      StringBuffer blz=new StringBuffer();
+      for (int i=0;i<4;i++)
+      {
+        if (rawData[20+i]!=(byte)0x20)
+        {
+        	byte nibble=(byte)((rawData[20+i]>>4)&0x0F);
+        	if (nibble>9) {
+        		nibble^=0x0F;
+        	}
+          blz.append((char)(nibble+0x30));
+          
+          nibble=(byte)(rawData[20+i]&0x0F);
+          if (nibble>9) {
+          	nibble^=0x0F;
+          }
+          blz.append((char)(nibble+0x30));
+        }
+      }
+      ret.blz=blz.toString();
+      
+      ret.commType  = rawData[24];
+      ret.commaddr  = new String(rawData,25,28,"ISO-8859-1").trim();
+      ret.commaddr2 = new String(rawData,53,2, "ISO-8859-1").trim();
+      ret.country   = new String(rawData,55,3, "ISO-8859-1").trim();
+      ret.userid    = new String(rawData,58,30,"ISO-8859-1").trim();
+      
+      return ret;
+    }
+    catch (HBCI_Exception e1)
+    {
+      throw e1;
+    }
+    catch (Exception e2)
+    {
+      throw new HBCI_Exception(e2);
+    }
+  }
+  
+  /**
+   * Speichert die Bank-Daten auf die Karte.
+   * @param idx Entry-Index.
+   * @param bankData die Bank-Daten.
+   */
+  public void writeBankData(int idx,DDVBankData bankData)
+  {
+    try
+    {
+      byte[] rawData=new byte[88];
+      
+      System.arraycopy(expand(bankData.shortname,20),0, rawData,0, 20);
+      
+      byte[] blzData=bankData.blz.getBytes("ISO-8859-1");
+      for (int i=0;i<4;i++)
+      {
+      	byte ch1=(byte)(blzData[i<<1    ]-0x30);
+      	byte ch2=(byte)(blzData[(i<<1)+1]-0x30);
+      	
+      	if (ch1==2 && ch2==0) {
+      		ch1^=0x0F;
+      	}
+      	
+        rawData[20+i] = (byte)((ch1<<4)|ch2);
+      }
+      
+      rawData[24]=(byte)bankData.commType;
+      System.arraycopy(expand(bankData.commaddr,28),0, rawData,25, 28);
+      System.arraycopy(expand(bankData.commaddr2,2),0, rawData,53, 2);
+      System.arraycopy(expand(bankData.country,3),  0, rawData,55, 3);
+      System.arraycopy(expand(bankData.userid,30),  0, rawData,58, 30);
+      
+      updateRecordBySFI(HBCI_DDV_EF_BNK,idx,rawData);
+    }
+    catch (HBCI_Exception e1)
+    {
+      throw e1;
+    }
+    catch (Exception e2)
+    {
+      throw new HBCI_Exception(e2);
+    }
+  }
+  
+  /**
+   * Liefert die Sig-ID.
+   * @return die Sig-ID.
+   */
+  public int readSigId()
+  {
+    int ret = -1;
+    
+    byte[] rawData=readRecordBySFI(HBCI_DDV_EF_SEQ, 0);
+    if (rawData!=null)
+      ret = ((rawData[0]<<8)&0xFF00) | (rawData[1]&0xFF);
+    
+    return ret;
+  }
+  
+  /**
+   * Speichert die Sig-ID.
+   * @param sigId die Sig-ID.
+   */
+  public void writeSigId(int sigId)
+  {
+    byte[] rawData=new byte[2];
+    rawData[0]=(byte)((sigId>>8)&0xFF);
+    rawData[1]=(byte)(sigId&0xFF);
+    updateRecordBySFI(HBCI_DDV_EF_SEQ,0,rawData);
+  }
+  
+  /**
+   * Signiert die Daten.
+   * @param data die zu signierenden Daten.
+   * @return die Signatur.
+   */
+  public byte[] sign(byte[] data)
+  {
+    byte[] data_l=new byte[8];
+    byte[] data_r=new byte[12];
+    
+    System.arraycopy(data,0,data_l,0,8);
+    System.arraycopy(data,8,data_r,0,12);
+    
+    updateRecordBySFI(HBCI_DDV_EF_MAC,0,data_r);
+    return calculateSignature(data_l);
+  }
+  
+  /**
+   * Liefert die Encryption-Keys.
+   * @param keynum Schluessel-Nummer.
+   * @return Encryption-Keys.
+   */
+  public byte[][] getEncryptionKeys(int keynum)
+  {
+    byte[][] keys=new byte[2][16];
+    
+    for (int i=0;i<2;i++)
+    {
+      byte[] challenge=getChallenge();
+      System.arraycopy(challenge,0,keys[0],i<<3,8);
+      byte[] enc=internalAuthenticate(keynum,challenge);
+      System.arraycopy(enc,0,keys[1],i<<3,8);
+    }
+    
+    return keys;
+  }
+  
+  /**
+   * Entschluesselt die Daten.
+   * @param keynum die Schluessel-Nummer.
+   * @param encdata die verschluesselten Daten.
+   * @return die entschluesselten Daten.
+   */
+  public byte[] decrypt(int keynum,byte[] encdata)
+  {
+    byte[] plaindata=new byte[16];
+    
+    for (int i=0;i<2;i++)
+    {
+      byte[] enc=new byte[8];
+      System.arraycopy(encdata,i<<3,enc,0,8);
+      byte[] plain=internalAuthenticate(keynum,enc);
+      System.arraycopy(plain,0,plaindata,i<<3,8);
+    }
+    
+    return plaindata;
+  }
+}
Index: src/org/kapott/hbci/smartcardio/DDVCardService0.java
===================================================================
RCS file: src/org/kapott/hbci/smartcardio/DDVCardService0.java
diff -N src/org/kapott/hbci/smartcardio/DDVCardService0.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/org/kapott/hbci/smartcardio/DDVCardService0.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,90 @@
+
+/*  $Id: 34-javax.smartcardio.patch,v 1.1 2011/11/24 21:59:37 willuhn Exp $
+
+    This file is part of HBCI4Java
+    Copyright (C) 2001-2008  Stefan Palme
+
+    HBCI4Java is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    HBCI4Java is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+package org.kapott.hbci.smartcardio;
+
+import javax.smartcardio.Card;
+import javax.smartcardio.CommandAPDU;
+
+/**
+ * DDV-Cardservice fuer Karten des Types 0, basierend auf dem OCF-Code aus HBCI4Java 2.5.8.
+ */
+public class DDVCardService0 extends DDVCardService
+{
+  /**
+   * @see org.kapott.hbci.smartcardio.HBCICardService#init(javax.smartcardio.Card)
+   */
+  public void init(Card card)
+  {
+    super.init(card);
+
+    // Select AID
+    // Kopiert aus org.kapott.hbci.ocf.CardServiceFactory.getCardType
+    CommandAPDU command = new CommandAPDU((byte)0x00, (byte)0xa4, (byte)0x04, (byte)0x0c,
+                                          new byte[] {(byte)0xd2, (byte)0x76,
+                                                      (byte)0x00, (byte)0x00,
+                                                      (byte)0x25, (byte)0x48,
+                                                      (byte)0x42, (byte)0x01,
+                                                      (byte)0x00});
+    send(command);
+  }
+
+
+  /**
+   * @see org.kapott.hbci.smartcardio.DDVCardService#readKeyData()
+   */
+  public DDVKeyData[] readKeyData()
+  {
+    DDVKeyData[] ret=new DDVKeyData[2];
+    
+    selectSubFile(0x0013);
+    byte[] rawData=readRecord(0);
+    ret[0]=new DDVKeyData();
+    ret[0].num=rawData[0];
+    ret[0].version=rawData[4];
+    ret[0].len=rawData[1];
+    ret[0].alg=rawData[2];
+
+    selectSubFile(0x0014);
+    rawData=readRecord(0);
+    ret[1]=new DDVKeyData();
+    ret[1].num=rawData[0];
+    ret[1].version=rawData[3];
+    ret[1].len=rawData[1];
+    ret[1].alg=rawData[2];
+    
+    return ret;
+  }
+  
+  /**
+   * @see org.kapott.hbci.smartcardio.DDVCardService#calculateSignature(byte[])
+   */
+  protected byte[] calculateSignature(byte[] data_l)
+  {
+    putData(0x0100,data_l);
+    CommandAPDU command=new CommandAPDU(SECCOS_CLA_SM_PROPR, SECCOS_INS_READ_RECORD,
+                                        (byte)0x01, (byte)((0x1B<<3)|0x04),256);
+    byte[] data = receive(command);
+    byte[] ret = new byte[8];
+    System.arraycopy(data,12,ret,0,8);
+    return ret;
+  }
+}
Index: src/org/kapott/hbci/smartcardio/DDVCardService1.java
===================================================================
RCS file: src/org/kapott/hbci/smartcardio/DDVCardService1.java
diff -N src/org/kapott/hbci/smartcardio/DDVCardService1.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/org/kapott/hbci/smartcardio/DDVCardService1.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,94 @@
+
+/*  $Id: 34-javax.smartcardio.patch,v 1.1 2011/11/24 21:59:37 willuhn Exp $
+
+    This file is part of HBCI4Java
+    Copyright (C) 2001-2008  Stefan Palme
+
+    HBCI4Java is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    HBCI4Java is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+package org.kapott.hbci.smartcardio;
+
+import javax.smartcardio.Card;
+import javax.smartcardio.CommandAPDU;
+
+/**
+ * DDV-Cardservice fuer Karten des Types 0, basierend auf dem OCF-Code aus HBCI4Java 2.5.8.
+ */
+public class DDVCardService1 extends DDVCardService
+{
+  /**
+   * @see org.kapott.hbci.smartcardio.HBCICardService#init(javax.smartcardio.Card)
+   */
+  public void init(Card card)
+  {
+    super.init(card);
+
+    // Select AID
+    // Kopiert aus org.kapott.hbci.ocf.CardServiceFactory.getCardType
+    CommandAPDU command = new CommandAPDU((byte)0x00, (byte)0xa4, (byte)0x04, (byte)0x0c,
+                                          new byte[] {(byte)0xd2, (byte)0x76,
+                                                      (byte)0x00, (byte)0x00,
+                                                      (byte)0x25, (byte)0x48,
+                                                      (byte)0x42, (byte)0x02,
+                                                      (byte)0x00});
+    send(command);
+  }
+
+  /**
+   * @see org.kapott.hbci.smartcardio.DDVCardService#readKeyData()
+   */
+  public DDVKeyData[] readKeyData()
+  {
+    DDVKeyData[] ret=new DDVKeyData[2];
+    
+    byte[] rawData=getKeyInfo(1);
+    ret[0]=new DDVKeyData();
+    ret[0].num=2;
+    ret[0].version=rawData[rawData.length-1];
+    ret[0].len=0;
+    ret[0].alg=0;
+    
+    rawData=getKeyInfo(2);
+    ret[1]=new DDVKeyData();
+    ret[1].num=3;
+    ret[1].version=rawData[rawData.length-1];
+    ret[1].len=0;
+    ret[1].alg=0;
+    
+    return ret;
+  }
+
+  /**
+   * @see org.kapott.hbci.smartcardio.DDVCardService#calculateSignature(byte[])
+   */
+  protected byte[] calculateSignature(byte[] data_l)
+  {
+    byte[] body=new byte[] {
+        SECCOS_SM_RESP_DESCR, (byte)0x0c, SECCOS_SM_CRT_CC, (byte)0x0a,
+        SECCOS_SM_REF_INIT_DATA, (byte)0x08, data_l[0], data_l[1], 
+        data_l[2], data_l[3], data_l[4], data_l[5], 
+        data_l[6], data_l[7], SECCOS_SM_VALUE_LE, (byte)0x01,
+        (byte)0x00};
+    
+    CommandAPDU command=new CommandAPDU(SECCOS_CLA_SM1, SECCOS_INS_READ_RECORD,
+                                        (byte)0x01, (byte)((0x1B<<3)|0x04),
+                                        body, 256);
+    byte[] data = receive(command);
+    byte[] ret = new byte[8];
+    System.arraycopy(data,16,ret,0,8);
+    return ret;
+  }
+}
Index: src/org/kapott/hbci/smartcardio/DDVKeyData.java
===================================================================
RCS file: src/org/kapott/hbci/smartcardio/DDVKeyData.java
diff -N src/org/kapott/hbci/smartcardio/DDVKeyData.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/org/kapott/hbci/smartcardio/DDVKeyData.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,42 @@
+
+/*  $Id: 34-javax.smartcardio.patch,v 1.1 2011/11/24 21:59:37 willuhn Exp $
+
+    This file is part of HBCI4Java
+    Copyright (C) 2001-2008  Stefan Palme
+
+    HBCI4Java is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    HBCI4Java is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+package org.kapott.hbci.smartcardio;
+
+/**
+ * DDV-Schluesseldaten fuer den DDVPCSC-Passport, basierend auf dem OCF-Code
+ * aus HBCI4Java 2.5.8.
+ */
+public class DDVKeyData
+{
+  public int num;
+  public int version;
+  public int len;
+  public int alg;
+  
+  /**
+   * @see java.lang.Object#toString()
+   */
+  public String toString()
+  {
+    return "key: num="+num+" version="+version+" len="+len+" alg="+alg;
+  }
+}
Index: src/org/kapott/hbci/smartcardio/HBCICardService.java
===================================================================
RCS file: src/org/kapott/hbci/smartcardio/HBCICardService.java
diff -N src/org/kapott/hbci/smartcardio/HBCICardService.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/org/kapott/hbci/smartcardio/HBCICardService.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,492 @@
+
+/*  $Id: 34-javax.smartcardio.patch,v 1.1 2011/11/24 21:59:37 willuhn Exp $
+
+    This file is part of HBCI4Java
+    Copyright (C) 2001-2008  Stefan Palme
+
+    HBCI4Java is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    HBCI4Java is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+package org.kapott.hbci.smartcardio;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.smartcardio.Card;
+import javax.smartcardio.CardChannel;
+import javax.smartcardio.CommandAPDU;
+import javax.smartcardio.ResponseAPDU;
+
+import org.kapott.hbci.exceptions.HBCI_Exception;
+import org.kapott.hbci.manager.HBCIUtils;
+
+/**
+ * HBCI-Cardservice fuer den DDVPCSC-Passport, basierend auf dem OCF-Code
+ * aus HBCI4Java 2.5.8.
+ */
+public abstract class HBCICardService 
+{
+  private final static Map<String,String> statusCodes = new HashMap<String,String>();
+  static
+  {
+    // Siehe http://de.wikipedia.org/wiki/Application_Protocol_Data_Unit
+    statusCodes.put("6281","Die zurückgegebenen Daten können fehlerhaft sein");
+    statusCodes.put("6282","Da das Dateiende vorher erreicht wurde, konnten nur weniger als Le Bytes gelesen werden");
+    statusCodes.put("6283","Die ausgewählte Datei ist gesperrt");
+    statusCodes.put("6284","Die File Control Information (FCI) ist nicht ISO 7816-4 konform");
+    
+    statusCodes.put("6381","File filled up by the last write");
+    
+    statusCodes.put("6581","Speicherfehler");
+    
+    statusCodes.put("6700","Länge (Lc oder Le) falsch");
+
+    statusCodes.put("6800","Funktionen im Class Byte werden nicht unterstützt");
+    statusCodes.put("6881","Logische Kanäle werden nicht unterstützt");
+    statusCodes.put("6882","Secure Messaging wird nicht unterstützt");
+    
+    statusCodes.put("6900","Kommando nicht erlaubt");
+    statusCodes.put("6981","Kommando inkompatibel zur Dateistruktur");
+    statusCodes.put("6982","Sicherheitszustand nicht erfüllt");
+    statusCodes.put("6983","Authentisierungsmethode ist gesperrt");
+    statusCodes.put("6984","Referenzierte Daten sind gesperrt");
+    statusCodes.put("6985","Nutzungsbedingungen sind nicht erfüllt");
+    statusCodes.put("6986","Kommando nicht erlaubt (kein EF selektiert)");
+    statusCodes.put("6987","Erwartete Secure Messaging Objekte nicht gefunden");
+    statusCodes.put("6988","Secure Messaging Datenobjekte sind inkorrekt");
+    
+    statusCodes.put("6A00","Falsche Parameter P1/P2");
+    statusCodes.put("6A80","Falsche Daten");
+    statusCodes.put("6A81","Funktion wird nicht unterstützt");
+    statusCodes.put("6A82","Datei wurde nicht gefunden");
+    statusCodes.put("6A83","Record der Datei nicht gefunden");
+    statusCodes.put("6A84","Nicht genügend Speicherplatz in der Datei");
+    statusCodes.put("6A85","Lc nicht konsistent mit der TLV Struktur");
+    statusCodes.put("6A86","Inkorrekte Parameter P1/P2");
+    statusCodes.put("6A87","Lc inkonsistent mit P1/P2");
+    statusCodes.put("6A88","Referenzierte Daten nicht gefunden");
+
+    statusCodes.put("6B00","Parameter P1/P2 falsch");
+    statusCodes.put("6D00","Das Kommando (INS) wird nicht unterstützt");
+    statusCodes.put("6E00","Die Kommandoklasse (CLA) wird nicht unterstützt");
+    statusCodes.put("6F00","Kommando wurde mit unbekanntem Fehler abgebrochen");
+  }
+  
+  final static int HBCI_DDV_EF_ID            = 0x19;
+  final static int HBCI_DDV_EF_BNK           = 0x1A;
+  final static int HBCI_DDV_EF_MAC           = 0x1B;
+  final static int HBCI_DDV_EF_SEQ           = 0x1C;
+  
+  final static int SECCOS_SELECT_RET_NOTHING = 0x0c;
+
+  final static int SECCOS_CLA_EXT            = 0xb0;
+  final static int SECCOS_CLA_SM_PROPR       = 0x04;
+  final static int SECCOS_CLA_SM1            = 0x08;
+  final static int SECCOS_CLA_STD            = 0x00;
+  
+  final static int SECCOS_INS_GET_CHALLENGE  = 0x84;
+  final static int SECCOS_INS_GET_KEYINFO    = 0xee;
+  final static int SECCOS_INS_INT_AUTH       = 0x88;
+  final static int SECCOS_INS_PUT_DATA       = 0xda;
+  final static int SECCOS_INS_READ_RECORD    = 0xb2;
+  final static int SECCOS_INS_SELECT_FILE    = 0xa4;
+  final static int SECCOS_INS_VERIFY         = 0x20;
+  final static int SECCOS_INS_UPDATE_RECORD  = 0xdc;
+  final static int SECCOS_INS_WRITE_RECORD   = 0xd2;
+  
+  final static int SECCOS_KEY_TYPE_DF = 0x80;
+  final static int SECCOS_PWD_TYPE_DF = 0x80;
+  
+  final static byte SECCOS_SM_CRT_CC        = (byte) 0xb4;
+  final static byte SECCOS_SM_REF_INIT_DATA = (byte) 0x87;
+  final static byte SECCOS_SM_RESP_DESCR    = (byte) 0xba;
+  final static byte SECCOS_SM_VALUE_LE      = (byte) 0x96;
+  
+  private final static String[] FEATURES = new String[]
+  {
+    "NO_FEATURE",
+    "FEATURE_VERIFY_PIN_START",
+    "FEATURE_VERIFY_PIN_FINISH",
+    "FEATURE_MODIFY_PIN_START",
+    "FEATURE_MODIFY_PIN_FINISH",
+    "FEATURE_GET_KEY_PRESSED",
+    "FEATURE_VERIFY_PIN_DIRECT",
+    "FEATURE_MODIFY_PIN_DIRECT",
+    "FEATURE_MCT_READER_DIRECT",
+    "FEATURE_MCT_UNIVERSAL",
+    "FEATURE_IFD_PIN_PROPERTIES",
+    "FEATURE_ABORT",
+    "FEATURE_SET_SPE_MESSAGE",
+    "FEATURE_VERIFY_PIN_DIRECT_APP_ID",
+    "FEATURE_MODIFY_PIN_DIRECT_APP_ID",
+    "FEATURE_WRITE_DISPLAY",
+    "FEATURE_GET_KEY",
+    "FEATURE_IFD_DISPLAY_PROPERTIES"
+  };
+
+  final static Byte FEATURE_VERIFY_PIN_START   = new Byte((byte) 0x01);
+  final static Byte FEATURE_VERIFY_PIN_FINISH  = new Byte((byte) 0x02);
+  final static Byte FEATURE_GET_KEY_PRESSED    = new Byte((byte) 0x05);
+  final static Byte FEATURE_VERIFY_PIN_DIRECT  = new Byte((byte) 0x06);
+  final static Byte FEATURE_MCT_READER_DIRECT  = new Byte((byte) 0x08);
+  final static Byte FEATURE_MCT_UNIVERSAL      = new Byte((byte) 0x09);
+  final static Byte FEATURE_IFD_PIN_PROPERTIES = new Byte((byte) 0x0a);
+
+  private final static int IOCTL_GET_FEATURE_REQUEST = SCARD_CTL_CODE(3400);
+
+  private Map<Byte, Integer> features = new HashMap<Byte,Integer>();
+  private Card smartCard = null;
+  
+  /**
+   * Ermittelt den Namen der Funktion zum Abrufen der Features aus der Karte.
+   * @param code der Code.
+   * @return der Funktions-Code.
+   */
+  private static int SCARD_CTL_CODE(int code)
+  {
+    if (System.getProperty("os.name").toLowerCase().indexOf("windows") != -1)
+      return (0x31 << 16 | (code) << 2);
+    return 0x42000000 + code;
+  }
+  
+  /**
+   * Initialisiert den Service mit der angegebenen Karte.
+   * @param card die Karte.
+   */
+  public void init(Card card)
+  {
+    this.smartCard = card;
+    
+    // Liste der Features abrufen
+    try
+    {
+      HBCIUtils.log("querying features",HBCIUtils.LOG_INFO);
+      byte[] response = this.smartCard.transmitControlCommand(IOCTL_GET_FEATURE_REQUEST, new byte[0]);
+      for (int i = 0; i < response.length; i += 6)
+      {
+        Byte feature = new Byte(response[i]);
+        Integer ioctl = new Integer((0xff & response[i + 2]) << 24)
+                                 | ((0xff & response[i + 3]) << 16)
+                                 | ((0xff & response[i + 4]) << 8)
+                                 | (0xff & response[i + 5]);
+        HBCIUtils.log("  " + FEATURES[feature.intValue()] + ": " + Integer.toHexString(ioctl.intValue()),HBCIUtils.LOG_INFO);
+        features.put(feature, ioctl);
+      }      
+    }
+    catch (Exception e)
+    {
+      throw new HBCI_Exception(e);
+    }
+  }
+  
+  /**
+   * Prueft die PIN via Kartenleser.
+   * @param pwdId PIN-ID.
+   */
+  public void verifyHardPIN(int pwdId)
+  {
+    try
+    {
+      byte[] response = this.smartCard.transmitControlCommand(features.get(FEATURE_VERIFY_PIN_DIRECT),this.createPINVerificationDataStructure());
+      
+      ResponseAPDU apdu = new ResponseAPDU(response);
+
+      //////////////////////////////////////////////////////////////////////////
+      // Extra Checks
+      int sw = apdu.getSW();
+      if (sw == 0x63c0) throw new HBCI_Exception("PIN falsch. Noch 1 Versuch");
+      if (sw == 0x63c1) throw new HBCI_Exception("PIN falsch. Noch 2 Versuche");
+      if (sw == 0x63c2) throw new HBCI_Exception("PIN falsch. Noch 3 Versuche");
+      if (sw == 0x6400) throw new HBCI_Exception("PIN-Eingabe aufgrund Timeout abgebrochen");
+      if (sw == 0x6401) throw new HBCI_Exception("PIN-Eingabe vom User abgebrochen");
+      if (sw == 0x6983) throw new HBCI_Exception("Chipkarte ist gesperrt oder besitzt ein unbekanntes Format");
+      //
+      //////////////////////////////////////////////////////////////////////////
+      
+      //////////////////////////////////////////////////////////////////////////
+      // Standard-Checks
+      this.check(apdu,new byte[]{(byte)0x90});
+      //
+      //////////////////////////////////////////////////////////////////////////
+    }
+    catch (HBCI_Exception he)
+    {
+      throw he;
+    }
+    catch (Exception e)
+    {
+      throw new HBCI_Exception(e);
+    }
+  }
+  
+  /**
+   * Prueft die PIN via Software.
+   * @param pwdId die PIN-ID.
+   * @param softPin die PIN.
+   */
+  public void verifySoftPIN(int pwdId, byte[] softPin)
+  {
+    byte[] body = new byte[] {(byte)0x25, (byte)0xff, (byte)0xff, (byte)0xff, 
+                              (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff};
+  
+    // pin bcd-kodiert in pin-2-block schreiben
+    for (int i=0;i<softPin.length;i++)
+    {
+      body[1+(i>>1)]&=(byte)(((0x0F)<<(4*(i&1)))&0xFF);
+      body[1+(i>>1)]|=(byte)(((softPin[i]-(byte)0x30) << (4-(4*(i&1))))&0xFF);
+    }
+    CommandAPDU command=new CommandAPDU(SECCOS_CLA_STD, SECCOS_INS_VERIFY,
+                                        (byte)0x00, (byte)(SECCOS_PWD_TYPE_DF|pwdId),
+                                        body);
+    send(command);
+  }
+  
+  protected void writeRecordBySFI(int sfi, int idx, byte[] data)
+  {
+    CommandAPDU command=new CommandAPDU(SECCOS_CLA_STD, SECCOS_INS_WRITE_RECORD,
+                                        (byte)(idx+1), (byte)((sfi<<3)|0x04),
+                                        data);
+    send(command);
+  }
+  
+  protected void updateRecordBySFI(int sfi, int idx, byte[] data)
+  {
+    CommandAPDU command=new CommandAPDU(SECCOS_CLA_STD, SECCOS_INS_UPDATE_RECORD,
+                                        (idx+1),((sfi<<3)|0x04),data);
+    send(command);
+  }
+  
+  protected byte[] readRecordBySFI(int sfi, int idx)
+  {
+    CommandAPDU command = new CommandAPDU(SECCOS_CLA_STD, SECCOS_INS_READ_RECORD,
+                                         (idx+1),((sfi<<3)|0x04),256);
+    return receive(command);
+  }
+  
+  protected byte[] readRecord(int idx)
+  {
+      return readRecordBySFI(0x00, idx);
+  }
+  
+  protected void selectSubFile(int id)
+  {
+    CommandAPDU command=new CommandAPDU(SECCOS_CLA_STD, SECCOS_INS_SELECT_FILE,
+                                        0x02, SECCOS_SELECT_RET_NOTHING,
+                                        new byte[] {(byte)((id>>8)&0xFF), (byte)(id&0xFF)});
+    send(command);
+  }
+  
+  protected byte[] getKeyInfo(int idx)
+  {
+    CommandAPDU command=new CommandAPDU(SECCOS_CLA_EXT, SECCOS_INS_GET_KEYINFO,
+                                        SECCOS_KEY_TYPE_DF,(idx+1),256);
+    return receive(command);
+  }
+  
+  protected void putData(int tag,byte[] data)
+  {
+    CommandAPDU command=new CommandAPDU(SECCOS_CLA_STD, SECCOS_INS_PUT_DATA,
+                                        (byte)((tag>>8)&0xFF), (byte)(tag&0xFF),
+                                        data);
+    send(command);
+  }
+  
+  protected byte[] getChallenge()
+  {
+    CommandAPDU command=new CommandAPDU(SECCOS_CLA_STD, SECCOS_INS_GET_CHALLENGE,
+                                        0x00,0x00,8);
+    return receive(command);
+  }
+  
+  protected byte[] internalAuthenticate(int keynum, byte[] challenge)
+  {
+    CommandAPDU command=new CommandAPDU(SECCOS_CLA_STD, SECCOS_INS_INT_AUTH,
+                                        0x00,(SECCOS_KEY_TYPE_DF|keynum),
+                                        challenge,8);
+    return receive(command);
+  }
+  
+  /**
+   * Sendet ein Kommando an den Kartenleser und prueft, ob es erfolgreich ausgefuehrt wurde.
+   * @param command das Kommando.
+   */
+  void send(CommandAPDU command)
+  {
+    // 0x90: Alles OK
+    // 0x61: Warnung - im Response sind noch Bytes verfuegbar. Da wir das Response
+    //       hier aber eh nicht brauchen, koennen wir das tolerieren
+    _receive(command,new byte[]{(byte)0x90,(byte)0x61});
+  }
+
+  /**
+   * Sendet ein Kommando an den Kartenleser, prueft ob es erfolgreich
+   * ausgefuehrt wurde und liefert die Antwort zurueck.
+   * @param command das Kommando.
+   * @return die Antwort.
+   */
+  byte[] receive(CommandAPDU command)
+  {
+    return _receive(command,new byte[]{(byte)0x90});
+  }
+
+  /**
+   * Sendet ein Kommando an den Kartenleser, prueft ob es erfolgreich
+   * ausgefuehrt wurde und liefert die Antwort zurueck.
+   * @param command das Kommando.
+   * @param returncodes zulaessige Return-Codes.
+   * @return die Antwort.
+   */
+  private byte[] _receive(CommandAPDU command, byte[] returncodes)
+  {
+    try
+    {
+      //////////////////////////////////////////////////////////////////////////
+      // Aufrufer ermitteln
+      String caller = "";
+      try
+      {
+        StackTraceElement[] stack = Thread.currentThread().getStackTrace();
+        caller = stack[3].getMethodName();
+      } catch (Exception e) {} // ignore
+      //////////////////////////////////////////////////////////////////////////
+      
+
+      CardChannel channel = this.smartCard.getBasicChannel();
+      ResponseAPDU response = channel.transmit(command);
+      
+      // Command und Response loggen
+      HBCIUtils.log(caller + " command : " + toHex(command.getBytes()),HBCIUtils.LOG_INFO); // TODO: Loglevel auf DEBUG aendern
+      HBCIUtils.log(caller + " response: " + toHex(response.getBytes()),HBCIUtils.LOG_INFO);// TODO: Loglevel auf DEBUG aendern
+
+      this.check(response,returncodes);
+      return response.getData();
+    }
+    catch (HBCI_Exception e1)
+    {
+      throw e1;
+    }
+    catch (Exception e2)
+    {
+      throw new HBCI_Exception(e2);
+    }
+  }
+  
+  /**
+   * Prueft das Response auf die angegebenen Return-Codes.
+   * @param response das Response.
+   * @param returncodes zulaessige Return-Codes.
+   */
+  private void check(ResponseAPDU response, byte[] returncodes)
+  {
+    // Return-Code pruefen
+    byte sw1 = (byte) response.getSW1();
+    for (byte b:returncodes)
+    {
+      if (sw1 == b) // Statuscode gefunden
+        return;
+    }
+
+    // Checken, ob wir einen Fehlertext haben
+    String code = Integer.toHexString(response.getSW()).toUpperCase();
+    String msg = statusCodes.get(code);
+    if (msg != null)
+      throw new HBCI_Exception("Fehler " + code + ": " + msg);
+    
+    // Ne, dann halt so
+    throw new HBCI_Exception("Fehler " + code + " bei Kartenleser-Zugriff");
+  }
+
+  /**
+   * Konvertiert die Bytes in HEX-Darstellung.
+   * @param bytes
+   * @return String-Repraesentation.
+   */
+  private String toHex(byte[] bytes)
+  {
+    StringBuffer sb = new StringBuffer();
+    for (byte b:bytes)
+    {
+      String s = Integer.toHexString(b & 0xff).toUpperCase();
+      if (s.length() == 1)
+        sb.append("0");
+      sb.append(s);
+      sb.append(" ");
+    }
+    return sb.toString();
+  }
+
+  /**
+   * Fuellt den String rechtsbuendig mit Leerzeichen auf die angegebene Laenge.
+   * @param st der String.
+   * @param len die Gesamtlaenge.
+   * @return der codierte String mit Leerzeichen auf der rechten Seite.
+   */
+  protected byte[] expand(String st,int len)
+  {
+    try {
+      StringBuffer st_new=new StringBuffer(st);
+      for (int i=st.length();i<len;i++) {
+          st_new.append(" ");
+      }
+      return st_new.toString().getBytes("ISO-8859-1");
+    }
+    catch (HBCI_Exception e1)
+    {
+      throw e1;
+    }
+    catch (Exception e2)
+    {
+      throw new HBCI_Exception(e2);
+    }
+  }
+  
+  /**
+   * Erzeugt das PIN-Check-Kommando.
+   * @return
+   * @throws IOException
+   */
+  private byte[] createPINVerificationDataStructure() throws IOException
+  {
+    ByteArrayOutputStream verifyCommand = new ByteArrayOutputStream();
+    verifyCommand.write(30); // bTimeOut
+    verifyCommand.write(30); // bTimeOut2
+    verifyCommand.write(0x80 | 0x08 | 0x00 | 0x01); // bmFormatString
+    verifyCommand.write(0x47); // bmPINBlockString
+    verifyCommand.write(0x04); // bmPINLengthFormat
+    verifyCommand.write(new byte[] {(byte) 12,(byte) 4}); // PIN size (max/min)
+    verifyCommand.write(0x02); // bEntryValidationCondition
+    verifyCommand.write(0x01); // bNumberMessage
+    verifyCommand.write(new byte[] { 0x13, 0x08 }); // wLangId
+    verifyCommand.write(0x00); // bMsgIndex
+    verifyCommand.write(new byte[] { 0x00, 0x00, 0x00 }); // bTeoPrologue
+    byte[] verifyApdu = new byte[] {
+        SECCOS_CLA_STD, // CLA
+        SECCOS_INS_VERIFY, // INS
+        0x00, // P1
+        0x01, // P2
+        0x08, // Lc = 8 bytes in command data
+        (byte) 0x20, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,
+        (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF };
+    verifyCommand.write(verifyApdu.length & 0xff); // ulDataLength[0]
+    verifyCommand.write(0x00); // ulDataLength[1]
+    verifyCommand.write(0x00); // ulDataLength[2]
+    verifyCommand.write(0x00); // ulDataLength[3]
+    verifyCommand.write(verifyApdu); // abData
+    return verifyCommand.toByteArray();
+  }
+}
Index: test/hbci4java/ddv/PCSCTest.java
===================================================================
RCS file: test/hbci4java/ddv/PCSCTest.java
diff -N test/hbci4java/ddv/PCSCTest.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ test/hbci4java/ddv/PCSCTest.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,99 @@
+/**********************************************************************
+ * $Source: /cvsroot/hibiscus/hbci4java/log/patches/34-javax.smartcardio.patch,v $
+ * $Revision: 1.1 $
+ * $Date: 2011/11/24 21:59:37 $
+ * $Author: willuhn $
+ *
+ * Copyright (c) by willuhn - software & services
+ * All rights reserved
+ *
+ **********************************************************************/
+
+package hbci4java.ddv;
+
+import hbci4java.AbstractTest;
+
+import java.io.File;
+
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.kapott.hbci.manager.HBCIUtils;
+import org.kapott.hbci.passport.AbstractHBCIPassport;
+import org.kapott.hbci.passport.HBCIPassportDDVPCSC;
+
+/**
+ * Testet den Zugriff auf eine Chipkarte via javax.smartcardio
+ */
+public class PCSCTest extends AbstractTest
+{
+  private static File dir = null;
+  HBCIPassportDDVPCSC passport = null;
+  
+  /**
+   * List die Daten aus der Karte.
+   * @throws Exception
+   */
+  @Test
+  public void testReadCardData() throws Exception
+  {
+    System.out.println("card id: " + passport.getCardId());
+    System.out.println("user id: " + passport.getUserId());
+    System.out.println("blz    : " + passport.getBLZ());
+    System.out.println("host   : " + passport.getHost());
+  }
+  
+  /**
+   * Erzeugt das Passport-Objekt.
+   * @throws Exception
+   */
+  @Before
+  public void beforeCard() throws Exception
+  {
+    HBCIUtils.setParam("client.passport.DDV.path",dir.getAbsolutePath() + "/");
+    HBCIUtils.setParam("client.passport.DDV.entryidx","1");
+    this.passport = (HBCIPassportDDVPCSC) AbstractHBCIPassport.getInstance("DDVPCSC");
+  }
+  
+  /**
+   * Schliesst das Passport-Objekt.
+   * @throws Exception
+   */
+  @After
+  public void afterCard() throws Exception
+  {
+    if (this.passport != null)
+      this.passport.close();
+  }
+  
+  /**
+   * Erzeugt das Passport-Verzeichnis.
+   * @throws Exception
+   */
+  @BeforeClass
+  public static void beforeCardClass() throws Exception
+  {
+    String tmpDir = System.getProperty("java.io.tmpdir","/tmp");
+    dir = new File(tmpDir,"ddvjava");
+    dir.mkdirs();
+  }
+  
+  /**
+   * Loescht das Passport-Verzeichnis.
+   * @throws Exception
+   */
+  @AfterClass
+  public static void afterCardClass() throws Exception
+  {
+    dir = null;
+    // TODO: Verzeichnis und Inhalt muesste mal noch geloescht werden.
+  }
+}
+
+
+
+/**********************************************************************
+ * $Log: 34-javax.smartcardio.patch,v $
+ * Revision 1.1  2011/11/24 21:59:37  willuhn
+ * @N Patch 33 - erster Code fuer PC/SC-Support via javax.smartcardio - noch nicht funktionsfaehig
+ *
+ **********************************************************************/
\ No newline at end of file
